import {aesWasm} from './aes-bg';
import {WordArray} from '../core/core';
import {BlockCipher} from '../core/cipher-core.js';
import {loadWasm} from '../utils/wasm-utils';
import {wasmBytes} from './aes-wasm';

// Lookup tables
const SBOX = [];
const INV_SBOX = [];
const SUB_MIX_0 = [];
const SUB_MIX_1 = [];
const SUB_MIX_2 = [];
const SUB_MIX_3 = [];
const INV_SUB_MIX_0 = [];
const INV_SUB_MIX_1 = [];
const INV_SUB_MIX_2 = [];
const INV_SUB_MIX_3 = [];

// Compute lookup tables

// Compute double table
const d = [];
for (let i = 0; i < 256; i++) {
  if (i < 128) {
    d[i] = i << 1;
  } else {
    d[i] = (i << 1) ^ 0x11b;
  }
}

// Walk GF(2^8)
let x = 0;
let xi = 0;
for (let i = 0; i < 256; i++) {
  // Compute sbox
  let sx = xi ^ (xi << 1) ^ (xi << 2) ^ (xi << 3) ^ (xi << 4);
  sx = (sx >>> 8) ^ (sx & 0xff) ^ 0x63;
  SBOX[x] = sx;
  INV_SBOX[sx] = x;

  // Compute multiplication
  const x2 = d[x];
  const x4 = d[x2];
  const x8 = d[x4];

  // Compute sub bytes, mix columns tables
  let t = (d[sx] * 0x101) ^ (sx * 0x1010100);
  SUB_MIX_0[x] = (t << 24) | (t >>> 8);
  SUB_MIX_1[x] = (t << 16) | (t >>> 16);
  SUB_MIX_2[x] = (t << 8) | (t >>> 24);
  SUB_MIX_3[x] = t;

  // Compute inv sub bytes, inv mix columns tables
  t = (x8 * 0x1010101) ^ (x4 * 0x10001) ^ (x2 * 0x101) ^ (x * 0x1010100);
  INV_SUB_MIX_0[sx] = (t << 24) | (t >>> 8);
  INV_SUB_MIX_1[sx] = (t << 16) | (t >>> 16);
  INV_SUB_MIX_2[sx] = (t << 8) | (t >>> 24);
  INV_SUB_MIX_3[sx] = t;

  // Compute next counter
  if (!x) {
    xi = 1;
    x = xi;
  } else {
    x = x2 ^ d[d[d[x8 ^ x2]]];
    xi ^= d[d[xi]];
  }
}

// Precomputed Rcon lookup
const RCON = [0x00, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36];

/**
 * AES block cipher algorithm.
 */
export class AESAlgo extends BlockCipher {
  static get keySize() {
    return 256 / 32;
  }

  static wasm = null;

  constructor(...args) {
    super(...args);

    this.keySize = 256 / 32;
  }

  static async loadWasm() {
    if (AESAlgo.wasm) {
      return AESAlgo.wasm;
    }

    AESAlgo.wasm = await loadWasm(wasmBytes);
    return AESAlgo.wasm;
  }

  async loadWasm() {
    return AESAlgo.loadWasm();
  }

  /**
   * Modified from glue code generated by wasm-build
   * @param mode
   * @param nRounds
   * @param nWordsReady
   * @param blockSize
   * @param iv
   * @param dataWords
   * @param keySchedule
   * @param SUB_MIX_0
   * @param SUB_MIX_1
   * @param SUB_MIX_2
   * @param SUB_MIX_3
   * @param SBOX
   * @private
   */
  _decrypt(mode, nRounds, nWordsReady, blockSize, iv, dataWords, keySchedule, SUB_MIX_0, SUB_MIX_1, SUB_MIX_2, SUB_MIX_3, SBOX) {
    if (!AESAlgo.wasm) {
      throw new Error('loadWasm should be called first.');
    }

    const wasm = AESAlgo.wasm;

    const ptr0 = this.passStringToWasm0(mode, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
    const len0 = this.WASM_VECTOR_LEN;
    const ptr1 = this.passArray32ToWasm0(iv, wasm.__wbindgen_malloc);
    const len1 = this.WASM_VECTOR_LEN;
    const ptr2 = this.passArray32ToWasm0(dataWords, wasm.__wbindgen_malloc);
    const len2 = this.WASM_VECTOR_LEN;
    const ptr3 = this.passArray32ToWasm0(keySchedule, wasm.__wbindgen_malloc);
    const len3 = this.WASM_VECTOR_LEN;
    const ptr4 = this.passArray32ToWasm0(SUB_MIX_0, wasm.__wbindgen_malloc);
    const len4 = this.WASM_VECTOR_LEN;
    const ptr5 = this.passArray32ToWasm0(SUB_MIX_1, wasm.__wbindgen_malloc);
    const len5 = this.WASM_VECTOR_LEN;
    const ptr6 = this.passArray32ToWasm0(SUB_MIX_2, wasm.__wbindgen_malloc);
    const len6 = this.WASM_VECTOR_LEN;
    const ptr7 = this.passArray32ToWasm0(SUB_MIX_3, wasm.__wbindgen_malloc);
    const len7 = this.WASM_VECTOR_LEN;
    const ptr8 = this.passArray32ToWasm0(SBOX, wasm.__wbindgen_malloc);
    const len8 = this.WASM_VECTOR_LEN;
    try {
      wasm.doDecrypt(ptr0, len0, nRounds, nWordsReady, blockSize, ptr1, len1, ptr2, len2, ptr3, len3, ptr4, len4, ptr5, len5, ptr6, len6, ptr7, len7, ptr8, len8);
    } finally {
      dataWords.set(this.getUint32Memory0().subarray(ptr2 / 4, ptr2 / 4 + len2));
      wasm.__wbindgen_free(ptr2, len2 * 4);
    }
  }

  _doReset() {
    let t;

    // Skip reset of nRounds has been set before and key did not change
    if (this._nRounds && this._keyPriorReset === this._key) {
      return;
    }

    // Shortcuts
    this._keyPriorReset = this._key;
    const key = this._keyPriorReset;
    const keyWords = key.words;
    const keySize = key.sigBytes / 4;

    // Compute number of rounds
    this._nRounds = keySize + 6;
    const nRounds = this._nRounds;

    // Compute number of key schedule rows
    const ksRows = (nRounds + 1) * 4;

    // Compute key schedule
    this._keySchedule = [];
    const keySchedule = this._keySchedule;
    for (let ksRow = 0; ksRow < ksRows; ksRow++) {
      if (ksRow < keySize) {
        keySchedule[ksRow] = keyWords[ksRow];
      } else {
        t = keySchedule[ksRow - 1];

        if (!(ksRow % keySize)) {
          // Rot word
          t = (t << 8) | (t >>> 24);

          // Sub word
          t = (SBOX[t >>> 24] << 24)
            | (SBOX[(t >>> 16) & 0xff] << 16)
            | (SBOX[(t >>> 8) & 0xff] << 8)
            | SBOX[t & 0xff];

          // Mix Rcon
          t ^= RCON[(ksRow / keySize) | 0] << 24;
        } else if (keySize > 6 && ksRow % keySize === 4) {
          // Sub word
          t = (SBOX[t >>> 24] << 24)
            | (SBOX[(t >>> 16) & 0xff] << 16)
            | (SBOX[(t >>> 8) & 0xff] << 8)
            | SBOX[t & 0xff];
        }

        keySchedule[ksRow] = keySchedule[ksRow - keySize] ^ t;
      }
    }

    // Compute inv key schedule
    this._invKeySchedule = [];
    const invKeySchedule = this._invKeySchedule;
    for (let invKsRow = 0; invKsRow < ksRows; invKsRow++) {
      const ksRow = ksRows - invKsRow;

      if (invKsRow % 4) {
        t = keySchedule[ksRow];
      } else {
        t = keySchedule[ksRow - 4];
      }

      if (invKsRow < 4 || ksRow <= 4) {
        invKeySchedule[invKsRow] = t;
      } else {
        invKeySchedule[invKsRow] = INV_SUB_MIX_0[SBOX[t >>> 24]]
          ^ INV_SUB_MIX_1[SBOX[(t >>> 16) & 0xff]]
          ^ INV_SUB_MIX_2[SBOX[(t >>> 8) & 0xff]]
          ^ INV_SUB_MIX_3[SBOX[t & 0xff]];
      }
    }
  }

  // eslint-disable-next-line no-dupe-class-members
  _process(doFlush) {
    if (!AESAlgo.wasm) {
      throw new Error('WASM is not loaded yet. \'loadWasm\' should be called first');
    }
    let processedWords;

    // Shortcuts
    const data = this._data;
    let dataWords = data.words;
    const dataSigBytes = data.sigBytes;
    const blockSize = this.blockSize;
    const blockSizeBytes = blockSize * 4;

    // Count blocks ready
    let nBlocksReady = dataSigBytes / blockSizeBytes;
    if (doFlush) {
      // Round up to include partial blocks
      nBlocksReady = Math.ceil(nBlocksReady);
    } else {
      // Round down to include only full blocks,
      // less the number of blocks that must remain in the buffer
      nBlocksReady = Math.max((nBlocksReady | 0) - this._minBufferSize, 0);
    }

    // Count words ready
    const nWordsReady = nBlocksReady * blockSize;

    // Count bytes ready
    const nBytesReady = Math.min(nWordsReady * 4, dataSigBytes);

    // Process blocks
    if (nWordsReady) {
      // dataArray.length should be n * 4
      if (dataWords.length % 4 != 0) {
        let count = 4 - dataWords.length % 4;
        while (count-- > 0) {
          dataWords.push(0);
        }
      }
      const dataArray = new Uint32Array(dataWords);
      const ivWords = this.cfg.iv ? this.cfg.iv.words : '';
      // Perform concrete-algorithm logic
      if (this._xformMode == this._ENC_XFORM_MODE) {
        aesWasm(AESAlgo.wasm).doEncrypt(this.cfg.mode.name, this._nRounds, nWordsReady, blockSize, ivWords, dataArray, this._keySchedule);
      } else /* if (this._xformMode == this._DEC_XFORM_MODE) */ {
        if (this.cfg.mode.name == 'CFB' || this.cfg.mode.name == 'OFB' || this.cfg.mode.name == 'CTR') {
          aesWasm(AESAlgo.wasm).doDecrypt(this.cfg.mode.name, this._nRounds, nWordsReady, blockSize, ivWords, dataArray, this._keySchedule);
        } else {
          aesWasm(AESAlgo.wasm).doDecrypt(this.cfg.mode.name, this._nRounds, nWordsReady, blockSize, ivWords, dataArray, this._invKeySchedule);
        }
      }
      dataWords = Array.from(dataArray);
      // Remove processed words
      processedWords = dataWords.splice(0, nWordsReady);

      data.sigBytes -= nBytesReady;
    }

    // Return processed words
    return new WordArray(processedWords, nBytesReady);
  }
}

/**
 * Shortcut functions to the cipher's object interface.
 *
 * @example
 *
 *     const ciphertext = CryptoJS.AES.encrypt(message, key, cfg);
 *     const plaintext  = CryptoJS.AES.decrypt(ciphertext, key, cfg);
 */
export const AES = BlockCipher._createHelper(AESAlgo);
